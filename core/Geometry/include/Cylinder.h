//This function generates the vertices for the cylinder in three parts :
//
//The top cap vertices are generated by looping through each segmentand calculating the xand z positions on the circle.The y position is set to half the height of the cylinder, and the normal is set to(0, 1, 0).
//
//The bottom cap vertices are generated in the same way as the top cap vertices, but with the y position set to negative half the height of the cylinder, and the normal set to(0, -1, 0).
//
//The side vertices are generated by looping through each segment againand generating two vertices per segment, one at the top of the cylinderand one at the bottom.The xand z positions are calculated as before, and the normal is set to the direction from the center of the cylinder to the vertex position.

//void generateCylinder(float radius, float height, int segments, float* vertices) {
//    const float PI = 3.14159265358979323846f;
//    float angle = 2.0f * PI / segments;
//    int i;
//    int vertexIndex = 0;
//
//    // Generate top cap vertices
//    for (i = 0; i <= segments; i++) {
//        float x = radius * cos(i * angle);
//        float z = radius * sin(i * angle);
//        vertices[vertexIndex++] = x;
//        vertices[vertexIndex++] = height / 2.0f;
//        vertices[vertexIndex++] = z;
//        vertices[vertexIndex++] = 1.0f;
//        vertices[vertexIndex++] = 0.0f;
//        vertices[vertexIndex++] = 0.0f;
//    }
//
//    // Generate bottom cap vertices
//    for (i = 0; i <= segments; i++) {
//        float x = radius * cos(i * angle);
//        float z = radius * sin(i * angle);
//        vertices[vertexIndex++] = x;
//        vertices[vertexIndex++] = -height / 2.0f;
//        vertices[vertexIndex++] = z;
//        vertices[vertexIndex++] = 0.0f;
//        vertices[vertexIndex++] = 1.0f;
//        vertices[vertexIndex++] = 0.0f;
//    }
//
//    // Generate side vertices
//    for (i = 0; i <= segments; i++) {
//        float x = radius * cos(i * angle);
//        float z = radius * sin(i * angle);
//        vertices[vertexIndex++] = x;
//        vertices[vertexIndex++] = height / 2.0f;
//        vertices[vertexIndex++] = z;
//        vertices[vertexIndex++] = x / radius;
//        vertices[vertexIndex++] = 0.0f;
//        vertices[vertexIndex++] = z / radius;
//
//        vertices[vertexIndex++] = x;
//        vertices[vertexIndex++] = -height / 2.0f;
//        vertices[vertexIndex++] = z;
//        vertices[vertexIndex++] = x / radius;
//        vertices[vertexIndex++] = 0.0f;
//        vertices[vertexIndex++] = z / radius;
//    }
//}